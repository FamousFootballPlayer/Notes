# 第五章 源码篇

## 5.1 字符串

### 5.1.1. Redis的字符串存储结构是怎样的？

C语言里字符串的标准形式是以NULL结尾的，Redis里并不这样表示，因为C语言的strlen函数的算法复杂度为O(n)，单线程的Redis表示不能承受。所以Redis的字符串叫做“SDS”，即Simple Dynamic String。结构如下：

    struct SDS<T>{
        T capacity;     //数组容量
        T len;          //数组长度
        byte flags;     //特殊标志位
        byte[] content; //数组内容
    }

该结构类似于Java中的ArrayList结构，其中capacity表示分配的空间长度，而len表示字符串的实际长度，content中存储的是真正的数据。由于字符串是可以修改的字符串，要支持append操作，如果数组没有冗余空间，就需要分配新数组，然后将旧内容复制过来，再append新内容，如果字符串的长度非常长，那么内存的分配和复制开销就会变大。

Redis的字符串有两种存储方式，再长度特别短时，使用embstr形式进行存储，当长度超过44字节时，使用raw形式进行存储。这两种方式的内存分布状况如下：

![](assets/embstrVSraw.png)

其中RedisObject代表是Redis对象的对象头结构，所有的Redis对象都有如下头结构：

    struct RedisObject{
        int4 type;
        int4 coding;
        int24 lru;
        int32 refcount;
        void *ptr;
    } robj;

其中type表示Redis对象的类型，同一个类型的type会有不同的存储形式coding，使用24位bit记录LRU信息，每个对象有一个引用计数，当引用技术为0时，对象就会被销毁，内存被回收。ptr指针指向对象内容的具体存储位置。这样一个RedisObject对象头结构占据16字节。考察SDS的存储结构，可以看出SDS对象头结构大小为capacity+3字节，因为除content外还有3字节的头信息，所以分配一个字符串最小占用19字节。由于内存分配器分配内存的大小单位都是2/4/8/16/32/64字节，64-19为45，由于字符串是以NULL结尾的，因此是44字节。

#### 5.1.1.1 数组容量、数组长度为何要使用泛型T？

当字符串比较短时，len和capacity可以使用byte和short来表示，Redis为了对内存做极致的优化，不同长度的字符串使用不同的结构体表示。Redis规定字符串的长度不能超过512MB，创建字符串时len和capacity一样长，不会多分配冗余空间，因为append操作修改字符串的情况很少。

#### 5.1.1.2 为什么Redis字符串最长为512MB?

    Actually the internal limit of an sds.c string, that is the dynamic string abstraction used inside Redis, is 2GB (as the string header represents length and remaining space as a signed 32 bit integers), but at some point we decided to reduce it to 512 MB since it's a large enough value anyway, and a 32 bit integer can address every bit inside a 512 MB value, that was handy for bit operations.

Redis作者表示实际上这种限制是一种内部限制，如果使用32位无符号数，string的限制应该为2GB，但是因为512MB足够大解决问题了，所以将其限制到512MB，32位整数可以解决512MB值内的每个位，这对位操作也十分方便。但是这也带来了问题，详见如下链接[Remove 512 MB max value limit #757](https://github.com/antirez/redis/issues/757)

### 5.1.2 扩容策略

字符串长度小于1MB之前，扩容采用加倍策略，超过1MB，则采用每次扩容多分配1MB空间的策略。

## 5.2 字典