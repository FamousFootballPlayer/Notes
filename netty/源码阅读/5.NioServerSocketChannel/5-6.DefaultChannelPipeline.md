# 5-6 DefaultChannelPipeline

## 1. 类注释

DefaultChannelPipeline是ChannelPipeline接口的默认实现。通常在Channel实例被创建的时候ChannelPipeline实例也被创建。

## 2. 属性

```java
    static final InternalLogger logger = InternalLoggerFactory.getInstance(DefaultChannelPipeline.class);

    @SuppressWarnings("unchecked")
    private static final WeakHashMap<Class<?>, String>[] nameCaches =
            new WeakHashMap[Runtime.getRuntime().availableProcessors()];

    static {
        for (int i = 0; i < nameCaches.length; i ++) {
            nameCaches[i] = new WeakHashMap<Class<?>, String>();
        }
    }
    /* ChannelPipeline应用的Channel */
    final AbstractChannel channel;

    /* AbstractChannelHandlerContext 链表 */
    final AbstractChannelHandlerContext head;
    final AbstractChannelHandlerContext tail;

    /* AbstractChannelHandlerContext 哈希表 */
    private final Map<String, AbstractChannelHandlerContext> name2ctx =
            new HashMap<String, AbstractChannelHandlerContext>(4);

    /**
     * @see #findInvoker(EventExecutorGroup)
     */
    private Map<EventExecutorGroup, ChannelHandlerInvoker> childInvokers;
```

## 3. 构造器

```java
    DefaultChannelPipeline(AbstractChannel channel) {
        if (channel == null) {
            throw new NullPointerException("channel");
        }
        this.channel = channel;

        tail = new TailContext(this);
        head = new HeadContext(this);

        head.next = tail;
        tail.prev = head;
    }
```

初始化channel，并设置AbstractChannelHandlerContext的头尾节点。因为入站处理过程和出站处理过程是相反的，因此，使用双向链表。

## 4. 一般方法

ChannelPipeline中的方法分为三类：

1. ChannelPipeline中ChannelHandler的管理方法
2. ChannelPipeline的信息获取方法
3. ChannelPipeline的事件驱动处理方法。

### 4.1 ChannelPipeline中ChannelHandler的管理方法

1. addFirst方法

    ```java
    @Override
    public ChannelPipeline addFirst(String name, ChannelHandler handler) {
        return addFirst((ChannelHandlerInvoker) null, name, handler);
    }

    @Override
    public ChannelPipeline addFirst(EventExecutorGroup group, String name, ChannelHandler handler) {
        synchronized (this) {
            name = filterName(name, handler);
            addFirst0(name, new DefaultChannelHandlerContext(this, findInvoker(group), name, handler));
        }
        return this;
    }

    @Override
    public ChannelPipeline addFirst(ChannelHandlerInvoker invoker, String name, ChannelHandler handler) {
        synchronized (this) {
            name = filterName(name, handler);
            addFirst0(name, new DefaultChannelHandlerContext(this, invoker, name, handler));
        }
        return this;
    }
    ```

    上述三个方法最终都是调用addFirest0()方法进行添加操作。大致逻辑都是:

    1. 调用filterName方法，筛选name是否已经存在。生成新的不重复的name
    2. 查找对应的invoker。
    3. 将现有数据拼装成DefaultChannelHandlerContext,调用addFirst0()方法进行添加。

    考察filterName方法如下：

    ```java
    private String filterName(String name, ChannelHandler handler) {
        if (name == null) {
            return generateName(handler);
        }

        if (!name2ctx.containsKey(name)) {
            return name;
        }

        throw new IllegalArgumentException("Duplicate handler name: " + name);
    }

    String generateName(ChannelHandler handler) {
        WeakHashMap<Class<?>, String> cache = nameCaches[(int) (Thread.currentThread().getId() % nameCaches.length)];
        Class<?> handlerType = handler.getClass();
        String name;
        synchronized (cache) {
            name = cache.get(handlerType);
            if (name == null) {
                name = generateName0(handlerType);
                cache.put(handlerType, name);
            }
        }

        synchronized (this) {
            // It's not very likely for a user to put more than one handler of the same type, but make sure to avoid
            // any name conflicts.  Note that we don't cache the names generated here.
            if (name2ctx.containsKey(name)) {
                String baseName = name.substring(0, name.length() - 1); // Strip the trailing '0'.
                for (int i = 1;; i ++) {
                    String newName = baseName + i;
                    if (!name2ctx.containsKey(newName)) {
                        name = newName;
                        break;
                    }
                }
            }
        }

        return name;
    }

    private static String generateName0(Class<?> handlerType) {
        return StringUtil.simpleClassName(handlerType) + "#0";
    }
    ```

    filterName()方法的目的是防止name2ctx或者nameCache中出现重复name。如果name重复了则对其更改，name格式为`类的简单类名#+数字`。如果出现简单类名相同的，则将名字最后的数字加一。

    考察findInvoker()方法如下:

    ```java
    // No need for synchronization because it is always executed in a synchronized(this) block.
    // 该方法没必要同步，因为执行该方法的部分总是被包含在synchronized(this)块里
    private ChannelHandlerInvoker findInvoker(EventExecutorGroup group) {
        if (group == null) {
            return null;
        }

        // Lazily initialize the data structure that maps an EventExecutorGroup to a ChannelHandlerInvoker.
        // 懒初始化
        Map<EventExecutorGroup, ChannelHandlerInvoker> childInvokers = this.childInvokers;
        if (childInvokers == null) {
            childInvokers = this.childInvokers = new IdentityHashMap<EventExecutorGroup, ChannelHandlerInvoker>(4);
        }

        // Pick one of the child executors and remember its invoker
        // so that the same invoker is used to fire events for the same channel.
        // 获取child executors并且记录对应的invoker
        // 对于相同的channel使用相同的invoker来触发事件
        ChannelHandlerInvoker  invoker = childInvokers.get(group);
        if (invoker == null) {
            EventExecutor executor = group.next();
            if (executor instanceof EventLoop) {
                invoker = ((EventLoop) executor).asInvoker();
            } else {
                invoker = new DefaultChannelHandlerInvoker(executor);
            }
            childInvokers.put(group, invoker);
        }

        return invoker;
    }
    ```

    最后将所有数据拼接，调用addFirst0方法进行添加。

    ```java
    private void addFirst0(String name, AbstractChannelHandlerContext newCtx) {
        // 检查ChannelHandler是否被重复添加
        checkMultiplicity(newCtx);
        // 将新的Context添加在链表头
        AbstractChannelHandlerContext nextCtx = head.next;
        newCtx.prev = head;
        newCtx.next = nextCtx;
        head.next = newCtx;
        nextCtx.prev = newCtx;
        // 将Context放入name2ctx中
        name2ctx.put(name, newCtx);
        // 成功添加的回调函数
        callHandlerAdded(newCtx);
    }
    ```

    ```java
    private static void checkMultiplicity(ChannelHandlerContext ctx) {
        ChannelHandler handler = ctx.handler();
        if (handler instanceof ChannelHandlerAdapter) {
            ChannelHandlerAdapter h = (ChannelHandlerAdapter) handler;
            // 检查handler是否被添加，并且检查是否是sharable的
            if (!h.isSharable() && h.added) {
                throw new ChannelPipelineException(
                        h.getClass().getName() +
                        " is not a @Sharable handler, so can't be added or removed multiple times.");
            }
            h.added = true;
        }
    }
    ```
